#include "can.h"

/* Start of autogenerated OD accessors */

/* End of autogenerated OD accessors */

static ODR_t OD_write_module_can_property(OD_stream_t *stream, const void *buf, OD_size_t count,
                                          OD_size_t *countWritten) {
    module_can_t *can = stream->object;
    (void)can;
    ODR_t result = OD_writeOriginal(stream, buf, count, countWritten);
    return result;
}

static int module_can_validate(OD_entry_t *config_entry) {
    module_can_config_t *config = (module_can_config_t *)OD_getPtr(config_entry, 0x01, 0, NULL);
    (void)config;
    if (false) {
        return CO_ERROR_OD_PARAMETERS;
    }
    return 0;
}

static int module_can_construct(module_can_t *can, device_t *device) {
    can->device = device;
    can->config = (module_can_config_t *)OD_getPtr(device->config, 0x01, 0, NULL);
    return can->config->disabled;
}

static int module_can_start(module_can_t *can) {
    device_gpio_configure_input("TX", can->config->tx_port, can->config->tx_pin);
    device_gpio_configure_output_with_value("RX", can->config->rx_port, can->config->rx_pin, 0);

    #ifdef STM32F1
      if (can->config->tx_port == 2 && can->config->tx_pin == 8) {
        rcc_periph_clock_enable(RCC_AFIO);
        gpio_primary_remap(                   // Map CAN1 to use PB8/PB9
            AFIO_MAPR_SWJ_CFG_JTAG_OFF_SW_ON, // Optional
            AFIO_MAPR_CAN1_REMAP_PORTB);
      }
    #endif

    return 0;
}

static int module_can_stop(module_can_t *can) {
    (void)can;
    return 0;
}

static int module_can_pause(module_can_t *can) {
    (void)can;
    return 0;
}

static int module_can_resume(module_can_t *can) {
    (void)can;
    return 0;
}

static int module_can_tick(module_can_t *can, uint32_t time_passed, uint32_t *next_tick) {
    (void)can;
    (void)time_passed;
    (void)next_tick;
    return 0;
}

static int module_can_link(module_can_t *can) {
    (void)can;
    return 0;
}

static int module_can_phase(module_can_t *can, device_phase_t phase) {
    (void)can;
    (void)phase;
    return 0;
}

device_callbacks_t module_can_callbacks = {
    .validate = module_can_validate,
    .construct = (int (*)(void *, device_t *))module_can_construct,
    .link = (int (*)(void *))module_can_link,
    .start = (int (*)(void *))module_can_start,
    .stop = (int (*)(void *))module_can_stop,
    .pause = (int (*)(void *))module_can_pause,
    .resume = (int (*)(void *))module_can_resume,
    .tick = (int (*)(void *, uint32_t time_passed, uint32_t *next_tick))module_can_tick,
    //.accept = (int (*)(void *, device_t *device, void *channel))module_can_accept,
    .phase = (int (*)(void *, device_phase_t phase))module_can_phase,
    .write_values = OD_write_module_can_property};
