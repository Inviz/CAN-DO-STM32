#include "can.h"
/* Start of autogenerated OD accessors */

/* End of autogenerated OD accessors */

static ODR_t OD_write_transport_can_property(OD_stream_t *stream, const void *buf, OD_size_t count,
                                          OD_size_t *countWritten) {
    transport_can_t *can = stream->object;
    (void)can;
    ODR_t result = OD_writeOriginal(stream, buf, count, countWritten);
    return result;
}

static int transport_can_validate(OD_entry_t *config_entry) {
    transport_can_config_t *config = (transport_can_config_t *)OD_getPtr(config_entry, 0x01, 0, NULL);
    (void)config;
    if (false) {
        return CO_ERROR_OD_PARAMETERS;
    }
    return 0;
}

static int transport_can_construct(transport_can_t *can, device_t *device) {
    can->device = device;
    can->config = (transport_can_config_t *)OD_getPtr(device->config, 0x01, 0, NULL);
    return can->config->disabled;
}

static int transport_can_start(transport_can_t *can) {
    device_gpio_configure_input("TX", can->config->tx_port, can->config->tx_pin);
    device_gpio_configure_output_with_value("RX", can->config->rx_port, can->config->rx_pin, 0);

    #ifdef STM32F1
      if (can->config->tx_port == 2 && can->config->tx_pin == 8) {
        rcc_periph_clock_enable(RCC_AFIO);
        gpio_primary_remap(                   // Map CAN1 to use PB8/PB9
            AFIO_MAPR_SWJ_CFG_JTAG_OFF_SW_ON, // Optional
            AFIO_MAPR_CAN1_REMAP_PORTB);
      }
    #endif

    return 0;
}

static int transport_can_stop(transport_can_t *can) {
    (void)can;
    return 0;
}

static int transport_can_pause(transport_can_t *can) {
    (void)can;
    return 0;
}

static int transport_can_resume(transport_can_t *can) {
    (void)can;
    return 0;
}

static int transport_can_tick(transport_can_t *can, uint32_t time_passed, uint32_t *next_tick) {
    (void)can;
    (void)time_passed;
    (void)next_tick;
    return 0;
}

static int transport_can_link(transport_can_t *can) {
    (void)can;
    return 0;
}

static int transport_can_phase(transport_can_t *can, device_phase_t phase) {
    (void)can;
    (void)phase;
    return 0;
}

device_callbacks_t transport_can_callbacks = {
    .validate = transport_can_validate,
    .construct = (int (*)(void *, device_t *))transport_can_construct,
    .link = (int (*)(void *))transport_can_link,
    .start = (int (*)(void *))transport_can_start,
    .stop = (int (*)(void *))transport_can_stop,
    .pause = (int (*)(void *))transport_can_pause,
    .resume = (int (*)(void *))transport_can_resume,
    .tick = (int (*)(void *, uint32_t time_passed, uint32_t *next_tick))transport_can_tick,
    //.accept = (int (*)(void *, device_t *device, void *channel))transport_can_accept,
    .phase = (int (*)(void *, device_phase_t phase))transport_can_phase,
    .write_values = OD_write_transport_can_property};
