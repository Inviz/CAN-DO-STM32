#include "can.h"
/* Start of autogenerated OD accessors */
OD_ACCESSORS(transport, can, properties, tx_port, SUBIDX_CAN_TX_PORT, uint8_t, u8) /* 0x62XX01: properties */
OD_ACCESSORS(transport, can, properties, tx_pin, SUBIDX_CAN_TX_PIN, uint8_t, u8) /* 0x62XX02: properties */
OD_ACCESSORS(transport, can, properties, rx_port, SUBIDX_CAN_RX_PORT, uint8_t, u8) /* 0x62XX03: properties */
OD_ACCESSORS(transport, can, properties, rx_pin, SUBIDX_CAN_RX_PIN, uint8_t, u8) /* 0x62XX04: properties */
OD_ACCESSORS(transport, can, properties, bitrate, SUBIDX_CAN_BITRATE, int16_t, i16) /* 0x62XX05: properties */
OD_ACCESSORS(transport, can, properties, brp, SUBIDX_CAN_BRP, uint16_t, u16) /* 0x62XX06: properties */
OD_ACCESSORS(transport, can, properties, sjw, SUBIDX_CAN_SJW, uint8_t, u8) /* 0x62XX07: properties */
OD_ACCESSORS(transport, can, properties, prop, SUBIDX_CAN_PROP, uint8_t, u8) /* 0x62XX08: properties */
OD_ACCESSORS(transport, can, properties, ph_seg1, SUBIDX_CAN_PH_SEG1, uint8_t, u8) /* 0x62XX09: properties */
OD_ACCESSORS(transport, can, properties, ph_seg2, SUBIDX_CAN_PH_SEG2, uint8_t, u8) /* 0x62XX0a: properties */
OD_ACCESSORS(transport, can, properties, phase, SUBIDX_CAN_PHASE, uint8_t, u8) /* 0x62XX0b: properties */
/* End of autogenerated OD accessors */

static ODR_t can_property_write(OD_stream_t *stream, const void *buf, OD_size_t count,
                                          OD_size_t *countWritten) {
    transport_can_t *can = stream->object;
    (void)can;
    ODR_t result = OD_writeOriginal(stream, buf, count, countWritten);
    return result;
}

static app_signal_t can_validate(OD_entry_t *properties_entry) {
    transport_can_properties_t *properties = (transport_can_properties_t *)OD_getPtr(properties_entry, 0x00, 0, NULL);
    (void)properties;
    if (false) {
        return CO_ERROR_OD_PARAMETERS;
    }
    return properties->tx_port == 0 || properties->rx_port == 0;
}

static app_signal_t can_phase_constructing(transport_can_t *can, device_t *device) {
    can->properties = (transport_can_properties_t *)OD_getPtr(device->properties, 0x00, 0, NULL);
    return can->properties->disabled;
}

static app_signal_t can_phase_starting(transport_can_t *can) {
    log_printf("    > CAN%i TX ", can->device->seq + 1);
    gpio_propertiesure_output(can->properties->tx_port, can->properties->tx_pin, 0);
    log_printf("    > CAN%i RX ", can->device->seq + 1);
    gpio_propertiesure_input(can->properties->rx_port, can->properties->rx_pin);

    #ifdef STM32F1
      if (can->properties->tx_port == 2 && can->properties->tx_pin == 8) {
        rcc_periph_clock_enable(RCC_AFIO);
        gpio_primary_remap(                   // Map CAN1 to use PB8/PB9
            AFIO_MAPR_SWJ_CFG_JTAG_OFF_SW_ON, // Optional
            AFIO_MAPR_CAN1_REMAP_PORTB);
      }
    #endif

    // Only propertiesure CAN interface if it's not claimed by CANopenNode
    if (can->canopen == NULL) {

    }

    return 0;
}

static app_signal_t can_phase_stoping(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_pausing(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_resuming(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_linking(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase(transport_can_t *can, device_phase_t phase) {
    (void)can;
    (void)phase;
    return 0;
}

// CANopenNode's driver propertiesures its CAN interface so we dont have to
static app_signal_t can_accept(transport_can_t *can, device_t *origin, void *arg) {
    (void) arg; 
    can->canopen = origin;
    return 0;
}

device_methods_t transport_can_methods = {
    .validate = can_validate,
    .phase_constructing = (app_signal_t (*)(void *, device_t *))can_phase_constructing,
    .phase_linking = (app_method_t) can_phase_linking,
    .phase_starting = (app_method_t) can_phase_starting,
    .phase_stoping = (app_method_t) can_phase_stoping,
    .phase_pausing = (app_method_t) can_phase_pausing,
    .phase_resuming = (app_method_t) can_phase_resuming,
    .callback_link = (int (*)(void *, device_t *device, void *channel))can_accept,
    .callback_phase = (app_signal_t (*)(void *, device_phase_t phase))can_phase,
    .property_write = can_property_write};
