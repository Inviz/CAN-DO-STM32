#include "can.h"
/* Start of autogenerated OD accessors */

/* End of autogenerated OD accessors */

static ODR_t can_property_write(OD_stream_t *stream, const void *buf, OD_size_t count,
                                          OD_size_t *countWritten) {
    transport_can_t *can = stream->object;
    (void)can;
    ODR_t result = OD_writeOriginal(stream, buf, count, countWritten);
    return result;
}

static app_signal_t can_validate(OD_entry_t *config_entry) {
    transport_can_config_t *config = (transport_can_config_t *)OD_getPtr(config_entry, 0x00, 0, NULL);
    (void)config;
    if (false) {
        return CO_ERROR_OD_PARAMETERS;
    }
    return config->tx_port == 0 || config->rx_port == 0;
}

static app_signal_t can_phase_constructing(transport_can_t *can, device_t *device) {
    can->config = (transport_can_config_t *)OD_getPtr(device->config, 0x00, 0, NULL);
    return can->config->disabled;
}

static app_signal_t can_phase_starting(transport_can_t *can) {
    log_printf("    > CAN%i TX ", can->device->seq + 1);
    gpio_configure_output(can->config->tx_port, can->config->tx_pin, 0);
    log_printf("    > CAN%i RX ", can->device->seq + 1);
    gpio_configure_input(can->config->rx_port, can->config->rx_pin);

    #ifdef STM32F1
      if (can->config->tx_port == 2 && can->config->tx_pin == 8) {
        rcc_periph_clock_enable(RCC_AFIO);
        gpio_primary_remap(                   // Map CAN1 to use PB8/PB9
            AFIO_MAPR_SWJ_CFG_JTAG_OFF_SW_ON, // Optional
            AFIO_MAPR_CAN1_REMAP_PORTB);
      }
    #endif

    // Only configure CAN interface if it's not claimed by CANopenNode
    if (can->canopen == NULL) {

    }

    return 0;
}

static app_signal_t can_phase_stoping(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_pausing(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_resuming(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase_linking(transport_can_t *can) {
    (void)can;
    return 0;
}

static app_signal_t can_phase(transport_can_t *can, device_phase_t phase) {
    (void)can;
    (void)phase;
    return 0;
}

// CANopenNode's driver configures its CAN interface so we dont have to
static app_signal_t can_accept(transport_can_t *can, device_t *origin, void *arg) {
    (void) arg; 
    can->canopen = origin;
    return 0;
}

device_methods_t transport_can_methods = {
    .validate = can_validate,
    .phase_constructing = (app_signal_t (*)(void *, device_t *))can_phase_constructing,
    .phase_linking = (app_method_t) can_phase_linking,
    .phase_starting = (app_method_t) can_phase_starting,
    .phase_stoping = (app_method_t) can_phase_stoping,
    .phase_pausing = (app_method_t) can_phase_pausing,
    .phase_resuming = (app_method_t) can_phase_resuming,
    .callback_link = (int (*)(void *, device_t *device, void *channel))can_accept,
    .callback_phase = (app_signal_t (*)(void *, device_phase_t phase))can_phase,
    .property_write = can_property_write};
