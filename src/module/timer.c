#include "timer.h"

/* Start of autogenerated OD accessors */

/* End of autogenerated OD accessors */

static ODR_t OD_write_module_timer_property(OD_stream_t *stream, const void *buf, OD_size_t count,
                                            OD_size_t *countWritten) {
    module_timer_t *blank = stream->object;
    (void)blank;
    ODR_t result = OD_writeOriginal(stream, buf, count, countWritten);
    return result;
}

static app_signal_t timer_validate(OD_entry_t *config_entry) {
    module_timer_config_t *config = (module_timer_config_t *)OD_getPtr(config_entry, 0x01, 0, NULL);
    (void)config;
    if (false) {
        return CO_ERROR_OD_PARAMETERS;
    }
    return 0;
}

static app_signal_t timer_phase_constructing(module_timer_t *blank, device_t *device) {
    blank->config = (module_timer_config_t *)OD_getPtr(device->config, 0x01, 0, NULL);
    return blank->config->disabled;
}

static app_signal_t timer_phase_starting(module_timer_t *blank) {
    (void)blank;
    return 0;
}

static app_signal_t timer_phase_stoping(module_timer_t *blank) {
    (void)blank;
    return 0;
}

static app_signal_t timer_phase_pausing(module_timer_t *blank) {
    (void)blank;
    return 0;
}

static app_signal_t timer_phase_resuming(module_timer_t *blank) {
    (void)blank;
    return 0;
}


static app_signal_t timer_phase_linking(module_timer_t *blank) {
    (void)blank;
    return 0;
}

static app_signal_t timer_phase(module_timer_t *blank, device_phase_t phase) {
    (void)blank;
    (void)phase;
    return 0;
}


//static app_signal_t mcu_timeout(device_mcu_t *mcu) {
//
//	/* Enable TIM2 clock. */
//	rcc_periph_clock_enable(RCC_TIM2);
//
//	/* Enable TIM2 interrupt. */
//	nvic_enable_irq(NVIC_TIM2_IRQ);
//
//	/* Reset TIM2 peripheral to defaults. */
//	rcc_periph_reset_pulse(RST_TIM2);
//
//	/* Timer global mode:
//	 * - No divider
//	 * - Alignment edge
//	 * - Direction up
//	 * (These are actually default values after reset above, so this call
//	 * is strictly unnecessary, but demos the api for alternative settings)
//	 */
//	timer_set_mode(TIM2, TIM_CR1_CKD_CK_INT,
//		TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);
//
//	/*
//	 * Please take note that the clock source for STM32 timers
//	 * might not be the raw APB1/APB2 clocks.  In various conditions they
//	 * are doubled.  See the Reference Manual for full details!
//	 * In our case, TIM2 on APB1 is running at double frequency, so this
//	 * sets the prescaler to have the timer run at 5kHz
//	 */
//	timer_set_prescaler(TIM2, ((rcc_apb1_frequency * 2) / 5000));
//
//	/* Disable preload. */
//	timer_disable_preload(TIM2);
//	timer_continuous_mode(TIM2);
//
//	/* count full range, as we'll update compare value continuously */
//	timer_set_period(TIM2, 65535);
//
//	/* Set the initual output compare value for OC1. */
//	timer_set_oc_value(TIM2, TIM_OC1, frequency_sequence[frequency_sel++]);
//
//	/* Counter enable. */
//	timer_enable_counter(TIM2);
//
//	/* Enable Channel 1 compare interrupt to recalculate compare values */
//	timer_enable_irq(TIM2, TIM_DIER_CC1IE);
//}

device_methods_t module_timer_methods = {.validate = timer_validate,
                                             .phase_constructing = (app_signal_t (*)(void *, device_t *))timer_phase_constructing,
                                             .phase_linking = (app_method_t) timer_phase_linking,
                                             .phase_starting = (app_method_t) timer_phase_starting,
                                             .phase_stoping = (app_method_t) timer_phase_stoping,
                                             .phase_pausing = (app_method_t) timer_phase_pausing,
                                             .phase_resuming = (app_method_t) timer_phase_resuming,
                                             //.accept = (int (*)(void *, device_t *device, void *channel))module_timer_accept,
                                             .callback_phase = (app_signal_t (*)(void *, device_phase_t phase))timer_phase,
                                             .write_values = OD_write_module_timer_property};
